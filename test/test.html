<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <title>Jasmine Spec Runner</title>

  <link rel="shortcut icon" type="image/png" href="jasmine-1.3.1/lib/jasmine-1.3.1/jasmine_favicon.png">
  <link rel="stylesheet" type="text/css" href="jasmine-1.3.1/lib/jasmine-1.3.1/jasmine.css">
  <script type="text/javascript" src="jasmine-1.3.1/lib/jasmine-1.3.1/jasmine.js"></script>
  <script type="text/javascript" src="jasmine-1.3.1/lib/jasmine-1.3.1/jasmine-html.js"></script>

  <!-- include source files here... -->
  <script type="text/javascript" src="../modules/TobliDate.js"></script>
  <script type="text/javascript" src="jasmine-1.3.1/src/Player.js"></script>
  <script type="text/javascript" src="jasmine-1.3.1/src/Song.js"></script>

  <!-- include spec files here... -->
  <script type="text/javascript" src="spec/SpecTobliDate.js"></script>
  <script type="text/javascript" src="jasmine-1.3.1/spec/SpecHelper.js"></script>
  <script type="text/javascript" src="jasmine-1.3.1/spec/PlayerSpec.js"></script>

  <script type="text/javascript">

	jasmine.Matchers.prototype.isAFunction = function(parameterObject) {
		// This is a hack I pulled from here: 
		// http://stackoverflow.com/questions/5999998/how-can-i-check-if-a-javascript-variable-is-function-type
		var retVal = (this.actual) && (({}).toString.call(this.actual) === '[object Function]');
		var pattern;
		if (retVal && parameterObject && parameterObject.withName) {
			pattern = new RegExp("^function\\s+" + parameterObject.withName + "\\s*\\(");
			retVal = (this.actual.toString().match(pattern) != null);
			if (!retVal) {
				this.message = function() {
					return ["function '" + this.actual.toString() + "' isn't named " + parameterObject.withName];
				};
			}
		}
		return retVal;
	};

	jasmine.Matchers.prototype.toBeAWellBehavedConstructor = function(parameterObject) {
		parameterObject = parameterObject || {};
		var cleanParamObj = {
			withParentClass:        (parameterObject.withParentClass        || Object     ), 
			whenCalledWith:         (parameterObject.whenCalledWith         || []         ),
			returningObjectOfClass: (parameterObject.returningObjectOfClass || this.actual),
			isFunctionParams:       (parameterObject.withName ? [{'withName': parameterObject.withName}] : [])
		};
		var messages = [];
		var retVal = jasmine.Matchers.prototype.isAFunction.apply(this, cleanParamObj.isFunctionParams);
		var constructorWrapper = null;
		var testObj = null;
		var testSubjectAsString = 
			this.actual.identity || 
			((this.actual === jasmine.undefined) && 'undefined') ||
			((this.actual === null) && 'null') ||
			this.actual.toString();
		if (!retVal) {
			if (this.message) {
				messages.push((this.message())[0]);
			} else if (this.actual.identity) {
				messages.push("Expected " + testSubjectAsString + " to be a function.");
			}
		} else {
			retVal = (this.actual.prototype !== jasmine.undefined) && (this.actual.prototype !== null);
			if (!retVal) {
				messages.push("Expected " + testSubjectAsString + " to have a non-null prototype.");
			} else {
				retVal = (this.actual.prototype.constructor === this.actual);
				if (!retVal) {
					messages.push("Expected " + testSubjectAsString + "'s prototype to point to itself.");
				} else {
					retVal = (Object.getPrototypeOf(this.actual.prototype) === cleanParamObj.withParentClass.prototype);
					if (!retVal) {
						messages.push("Expected different parent class.");
					} else {
						constructorWrapper = function (constructor) {
							return constructor.apply(this, cleanParamObj.whenCalledWith);
						};
						constructorWrapper.prototype = this.actual.prototype;
						testObj = new constructorWrapper(this.actual);
						retVal =
							testObj &&
							(testObj instanceof this.actual) &&
							(testObj instanceof cleanParamObj.returningObjectOfClass) &&
							(testObj.constructor === cleanParamObj.returningObjectOfClass) &&
							(Object.getPrototypeOf(testObj) === cleanParamObj.returningObjectOfClass.prototype);
						if (!retVal) {
							messages.push("Constructor doesn't return object of requested type.");
						}
					}
				}
			}
		}
		if (!retVal) {
			this.message = function() {
				return messages;
			};
		}
		return retVal;
	};
	
    (function() {
      var jasmineEnv = jasmine.getEnv();
      jasmineEnv.updateInterval = 1000;

      var htmlReporter = new jasmine.HtmlReporter();

      jasmineEnv.addReporter(htmlReporter);

      jasmineEnv.specFilter = function(spec) {
        return htmlReporter.specFilter(spec);
      };

      var currentWindowOnload = window.onload;

      window.onload = function() {
        if (currentWindowOnload) {
          currentWindowOnload();
        }
        execJasmine();
      };

      function execJasmine() {
        jasmineEnv.execute();
      }

    })();
  </script>

</head>

<body>
</body>
</html>
